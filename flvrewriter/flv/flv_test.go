package flv

import (
	"bytes"
	"testing"
)

func TestTagHeaderGetBytes(t *testing.T) {
	expectedTagHeaderb := []byte{0x00, 0x00, 0x01, 0x12, 0x09, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	tagHeader := &TagHeader{
		PrevSize:  274,
		TagType:   TagType_Video,
		DataSize:  48,
		TimeStamp: 0,
		TimeExtra: 0,
		StreamId:  [3]byte{0, 0, 0},
	}
	tagb := tagHeader.GetBytes()
	if len(tagb) != TagHeaderSize ||
		!bytes.Equal(tagb, expectedTagHeaderb) {
		t.Errorf("TagHeader.GetBytes failed, expected: % x, got: % x", expectedTagHeaderb, tagb)
	}
}

func TestFlvHeaderGetBytes(t *testing.T) {
	expectedFlvHeader := []byte{0x46, 0x4c, 0x56, 0x01, 0x01, 0x00, 0x00, 0x00, 0x09, // flv header
		0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // script tag header
		0x02, 0x00, 0x0A, 0x6F, 0x6E, 0x4D, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61, 0x08, 0x00, 0x00,
		0x00, 0x0b, 0x00, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x40, 0x7b, 0x2c,
		0x28, 0xf5, 0xc2, 0x8f, 0x5c, 0x00, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x00, 0x40, 0x94, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x00, 0x40, 0x86,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x64, 0x61, 0x74,
		0x61, 0x72, 0x61, 0x74, 0x65, 0x00, 0x40, 0xa0, 0xae, 0x05, 0x00, 0x92, 0xcc, 0xf7, 0x00, 0x09,
		0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x00, 0x40, 0x39, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0c, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x69, 0x64,
		0x00, 0x40, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x6d, 0x61, 0x6a, 0x6f, 0x72,
		0x5f, 0x62, 0x72, 0x61, 0x6e, 0x64, 0x02, 0x00, 0x04, 0x69, 0x73, 0x6f, 0x6d, 0x00, 0x0d, 0x6d,
		0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x02, 0x00, 0x03, 0x35,
		0x31, 0x32, 0x00, 0x11, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x5f, 0x62,
		0x72, 0x61, 0x6e, 0x64, 0x73, 0x02, 0x00, 0x10, 0x69, 0x73, 0x6f, 0x6d, 0x69, 0x73, 0x6f, 0x32,
		0x61, 0x76, 0x63, 0x31, 0x6d, 0x70, 0x34, 0x31, 0x00, 0x07, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65,
		0x72, 0x02, 0x00, 0x0d, 0x4c, 0x61, 0x76, 0x66, 0x35, 0x38, 0x2e, 0x34, 0x35, 0x2e, 0x31, 0x30,
		0x30, 0x00, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x69, 0x7a, 0x65, 0x00, 0x41, 0x9c, 0x60, 0x51,
		0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09}
	scriptTagDataSize := 263
	flvHeader := &FlvHeader{
		Header: [FlvHeaderSize]byte{'F', 'L', 'V', 0x01, 0x01, 0x00, 0x00, 0x00, 0x09},
		ScriptTagHeader: TagHeader{
			PrevSize:  0,
			TagType:   TagType_Meta,
			DataSize:  uint32(scriptTagDataSize),
			TimeStamp: 0,
			TimeExtra: 0,
			StreamId:  [3]byte{0, 0, 0},
		},
		ScriptTagData: []byte{},
		Meta: map[string]interface{}{
			"duration":          434.76000,
			"width":             1280.0,
			"height":            720.0,
			"videodatarate":     2135.00977,
			"framerate":         25.00000,
			"videocodecid":      7.0,
			"major_brand":       "isom",
			"minor_version":     "512",
			"compatible_brands": "isomiso2avc1mp41",
			"encoder":           "Lavf58.45.100",
			"filesize":          119018579.0,
		},
		DebugOrder: []string{"duration", "width", "height", "videodatarate", "framerate", "videocodecid", "major_brand", "minor_version", "compatible_brands", "encoder", "filesize"},
	}
	flvHeaderb := flvHeader.GetBytes(true)
	if len(flvHeaderb) != FlvHeaderSize+TagHeaderSize+scriptTagDataSize ||
		!bytes.Equal(flvHeaderb, expectedFlvHeader) {
		t.Errorf("FlvHeader.GetBytes failed, expected: % x, got: % x", expectedFlvHeader, flvHeaderb)
	}
}
